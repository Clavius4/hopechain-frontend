{"ast":null,"code":"import { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode } from './agent';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nimport managementCanisterIdl from './canisters/management_idl';\nexport class ActorCallError extends AgentError {\n  constructor(canisterId, methodName, type, props) {\n    super([`Call failed:`, `  Canister: ${canisterId.toText()}`, `  Method: ${methodName} (${type})`, ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`)].join('\\n'));\n    this.canisterId = canisterId;\n    this.methodName = methodName;\n    this.type = type;\n    this.props = props;\n  }\n}\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, result) {\n    var _a;\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message\n    });\n    this.result = result;\n  }\n}\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, requestId, response) {\n    super(canisterId, methodName, 'update', Object.assign({\n      'Request ID': toHex(requestId)\n    }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {\n      'Error code': response.body.error_code\n    } : {}), {\n      'Reject code': String(response.body.reject_code),\n      'Reject message': response.body.reject_message\n    }) : {\n      'HTTP status code': response.status.toString(),\n      'HTTP status text': response.statusText\n    }));\n    this.requestId = requestId;\n    this.response = response;\n  }\n}\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  constructor(metadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  static agentOf(actor) {\n    return actor[metadataSymbol].config.agent;\n  }\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  static interfaceOf(actor) {\n    return actor[metadataSymbol].service;\n  }\n  static canisterIdOf(actor) {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n  static async install(fields, config) {\n    const mode = fields.mode === undefined ? {\n      install: null\n    } : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n    await getManagementCanister(config).install_code({\n      mode,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n      sender_canister_version: []\n    });\n  }\n  static async createCanister(config, settings) {\n    function settingsToCanisterSettings(settings) {\n      return [{\n        controllers: settings.controllers ? [settings.controllers] : [],\n        compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n        freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n        memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n        reserved_cycles_limit: [],\n        log_visibility: [],\n        wasm_memory_limit: []\n      }];\n    }\n    const {\n      canister_id: canisterId\n    } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: settingsToCanisterSettings(settings || {}),\n      specified_id: [],\n      sender_canister_version: []\n    });\n    return canisterId;\n  }\n  static async createAndInstallCanister(interfaceFactory, fields, config) {\n    const canisterId = await this.createCanister(config);\n    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n  }\n  static createActorClass(interfaceFactory, options) {\n    const service = interfaceFactory({\n      IDL\n    });\n    class CanisterActor extends Actor {\n      constructor(config) {\n        if (!config.canisterId) throw new AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n        const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n        super({\n          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {\n            canisterId\n          }),\n          service\n        });\n        for (const [methodName, func] of service._fields) {\n          if (options === null || options === void 0 ? void 0 : options.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options === null || options === void 0 ? void 0 : options.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n    return CanisterActor;\n  }\n  static createActor(interfaceFactory, configuration) {\n    if (!configuration.canisterId) {\n      throw new AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n    }\n    return new (this.createActorClass(interfaceFactory))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  static createActorWithHttpDetails(interfaceFactory, configuration) {\n    return new (this.createActorClass(interfaceFactory, {\n      httpDetails: true\n    }))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {\n    httpDetails: true,\n    certificate: true\n  }) {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n  }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy\n};\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n  let caller;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      var _a, _b;\n      // First, if there's a config transformation, call it.\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId\n      });\n      const httpDetails = Object.assign(Object.assign({}, result.httpDetails), {\n        requestDetails: result.requestDetails\n      });\n      switch (result.status) {\n        case \"rejected\" /* QueryResponseStatus.Rejected */:\n          throw new QueryCallRejectedError(cid, methodName, result);\n        case \"replied\" /* QueryResponseStatus.Replied */:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, result.reply.arg)\n          } : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      var _a, _b;\n      // First, if there's a config transformation, call it.\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const {\n        canisterId,\n        effectiveCanisterId,\n        pollingStrategyFactory\n      } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const {\n        requestId,\n        response,\n        requestDetails\n      } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid\n      });\n      requestId;\n      response;\n      requestDetails;\n      if (!response.ok || response.body /* IC-1462 */) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n      const pollStrategy = pollingStrategyFactory();\n      // Contains the certificate and the reply from the boundary node\n      const {\n        certificate,\n        reply\n      } = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n      reply;\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n      const httpDetails = Object.assign(Object.assign({}, response), {\n        requestDetails\n      });\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails ? {\n          httpDetails: response,\n          result: undefined\n        } : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n  const handler = (...args) => caller({}, ...args);\n  handler.withOptions = options => (...args) => caller(options, ...args);\n  return handler;\n}\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nexport function getManagementCanister(config) {\n  function transform(_methodName, args) {\n    if (config.effectiveCanisterId) {\n      return {\n        effectiveCanisterId: Principal.from(config.effectiveCanisterId)\n      };\n    }\n    const first = args[0];\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id);\n    }\n    return {\n      effectiveCanisterId\n    };\n  }\n  return Actor.createActor(managementCanisterIdl, Object.assign(Object.assign(Object.assign({}, config), {\n    canisterId: Principal.fromHex('')\n  }), {\n    callTransform: transform,\n    queryTransform: transform\n  }));\n}\nexport class AdvancedActor extends Actor {\n  constructor(metadata) {\n    super(metadata);\n  }\n}","map":{"version":3,"names":["Buffer","getDefaultAgent","ReplicaRejectCode","AgentError","IDL","pollForResponse","strategy","Principal","toHex","managementCanisterIdl","ActorCallError","constructor","canisterId","methodName","type","props","toText","Object","getOwnPropertyNames","map","n","JSON","stringify","join","QueryCallRejectedError","result","Status","status","Code","_a","reject_code","Message","reject_message","UpdateCallRejectedError","requestId","response","assign","body","error_code","String","toString","statusText","metadataSymbol","Symbol","for","Actor","metadata","freeze","agentOf","actor","config","agent","interfaceOf","service","canisterIdOf","from","install","fields","mode","undefined","arg","Uint8Array","wasmModule","module","fromText","getManagementCanister","install_code","wasm_module","canister_id","sender_canister_version","createCanister","settings","settingsToCanisterSettings","controllers","compute_allocation","freezing_threshold","memory_allocation","reserved_cycles_limit","log_visibility","wasm_memory_limit","provisional_create_canister_with_cycles","amount","specified_id","createAndInstallCanister","interfaceFactory","createActor","createActorClass","options","CanisterActor","DEFAULT_ACTOR_CONFIG","func","_fields","httpDetails","annotations","push","ACTOR_METHOD_WITH_HTTP_DETAILS","certificate","ACTOR_METHOD_WITH_CERTIFICATE","_createActorMethod","blsVerify","configuration","createActorWithHttpDetails","createActorWithExtendedDetails","actorClassOptions","decodeReturnValue","types","msg","returnValues","decode","length","pollingStrategyFactory","defaultStrategy","caller","includes","args","_b","queryTransform","call","cid","encode","argTypes","query","effectiveCanisterId","requestDetails","retTypes","reply","callTransform","ecid","ok","pollStrategy","shouldIncludeHttpDetails","shouldIncludeCertificate","Error","handler","withOptions","transform","_methodName","first","fromHex","AdvancedActor"],"sources":["/home/jeco/myprojects/icp/hopechain-frontend/node_modules/@dfinity/agent/src/actor.ts"],"sourcesContent":["import { Buffer } from 'buffer/';\nimport {\n  Agent,\n  getDefaultAgent,\n  HttpDetailsResponse,\n  QueryResponseRejected,\n  QueryResponseStatus,\n  ReplicaRejectCode,\n  SubmitResponse,\n} from './agent';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, PollStrategyFactory, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { RequestId } from './request_id';\nimport { toHex } from './utils/buffer';\nimport { Certificate, CreateCertificateOptions } from './certificate';\nimport managementCanisterIdl from './canisters/management_idl';\nimport _SERVICE, { canister_install_mode, canister_settings } from './canisters/management_service';\n\nexport class ActorCallError extends AgentError {\n  constructor(\n    public readonly canisterId: Principal,\n    public readonly methodName: string,\n    public readonly type: 'query' | 'update',\n    public readonly props: Record<string, string>,\n  ) {\n    super(\n      [\n        `Call failed:`,\n        `  Canister: ${canisterId.toText()}`,\n        `  Method: ${methodName} (${type})`,\n        ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n      ].join('\\n'),\n    );\n  }\n}\n\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly result: QueryResponseRejected,\n  ) {\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: ReplicaRejectCode[result.reject_code] ?? `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message,\n    });\n  }\n}\n\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly requestId: RequestId,\n    public readonly response: SubmitResponse['response'],\n  ) {\n    super(canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      ...(response.body\n        ? {\n            ...(response.body.error_code\n              ? {\n                  'Error code': response.body.error_code,\n                }\n              : {}),\n            'Reject code': String(response.body.reject_code),\n            'Reject message': response.body.reject_message,\n          }\n        : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n          }),\n    });\n  }\n}\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * A polling strategy factory that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   */\n  pollingStrategyFactory?: PollStrategyFactory;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodExtended<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{\n    certificate?: Certificate;\n    httpDetails?: HttpDetailsResponse;\n    result: Ret;\n  }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedExtended<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodExtended<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n  certificate?: boolean;\n}\n\ninterface CreateCanisterSettings {\n  freezing_threshold?: bigint;\n  controllers?: Array<Principal>;\n  memory_allocation?: bigint;\n  compute_allocation?: bigint;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static async install(\n    fields: {\n      module: ArrayBuffer;\n      mode?: canister_install_mode;\n      arg?: ArrayBuffer;\n    },\n    config: ActorConfig,\n  ): Promise<void> {\n    const mode = fields.mode === undefined ? { install: null } : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId =\n      typeof config.canisterId === 'string'\n        ? Principal.fromText(config.canisterId)\n        : config.canisterId;\n\n    await getManagementCanister(config).install_code({\n      mode,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n      sender_canister_version: [],\n    });\n  }\n\n  public static async createCanister(\n    config?: CallConfig,\n    settings?: CreateCanisterSettings,\n  ): Promise<Principal> {\n    function settingsToCanisterSettings(settings: CreateCanisterSettings): [canister_settings] {\n      return [\n        {\n          controllers: settings.controllers ? [settings.controllers] : [],\n          compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n          freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n          memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n          reserved_cycles_limit: [],\n          log_visibility: [],\n          wasm_memory_limit: [],\n        },\n      ];\n    }\n\n    const { canister_id: canisterId } = await getManagementCanister(\n      config || {},\n    ).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: settingsToCanisterSettings(settings || {}),\n      specified_id: [],\n      sender_canister_version: [],\n    });\n\n    return canisterId;\n  }\n\n  public static async createAndInstallCanister(\n    interfaceFactory: IDL.InterfaceFactory,\n    fields: {\n      module: ArrayBuffer;\n      arg?: ArrayBuffer;\n    },\n    config?: CallConfig,\n  ): Promise<ActorSubclass> {\n    const canisterId = await this.createCanister(config);\n    await this.install(\n      {\n        ...fields,\n      },\n      { ...config, canisterId },\n    );\n\n    return this.createActor(interfaceFactory, { ...config, canisterId });\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId)\n          throw new AgentError(\n            `Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n          );\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw new AgentError(\n        `Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n      );\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  public static createActorWithExtendedDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n    actorClassOptions: CreateActorClassOpts = {\n      httpDetails: true,\n      certificate: true,\n    },\n  ): ActorSubclass<ActorMethodMappedExtended<T>> {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedExtended<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: ArrayBuffer) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails,\n      } as HttpDetailsResponse;\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          throw new QueryCallRejectedError(cid, methodName, result);\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n\n      const { requestId, response, requestDetails } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n      });\n\n      requestId;\n      response;\n      requestDetails;\n\n      if (!response.ok || response.body /* IC-1462 */) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n\n      const pollStrategy = pollingStrategyFactory();\n      // Contains the certificate and the reply from the boundary node\n      const { certificate, reply } = await pollForResponse(\n        agent,\n        ecid,\n        requestId,\n        pollStrategy,\n        blsVerify,\n      );\n      reply;\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n\n      const httpDetails = { ...response, requestDetails } as HttpDetailsResponse;\n\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n\nexport type ManagementCanisterRecord = _SERVICE;\n\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nexport function getManagementCanister(config: CallConfig): ActorSubclass<ManagementCanisterRecord> {\n  function transform(\n    _methodName: string,\n    args: Record<string, unknown> & { canister_id: string }[],\n  ) {\n    if (config.effectiveCanisterId) {\n      return { effectiveCanisterId: Principal.from(config.effectiveCanisterId) };\n    }\n    const first = args[0];\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id as unknown);\n    }\n    return { effectiveCanisterId };\n  }\n\n  return Actor.createActor<ManagementCanisterRecord>(managementCanisterIdl, {\n    ...config,\n    canisterId: Principal.fromHex(''),\n    ...{\n      callTransform: transform,\n      queryTransform: transform,\n    },\n  });\n}\n\nexport class AdvancedActor extends Actor {\n  constructor(metadata: ActorMetadata) {\n    super(metadata);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}