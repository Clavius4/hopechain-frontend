{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HttpAgent_instances, _HttpAgent_identity, _HttpAgent_fetch, _HttpAgent_fetchOptions, _HttpAgent_callOptions, _HttpAgent_timeDiffMsecs, _HttpAgent_credentials, _HttpAgent_rootKeyFetched, _HttpAgent_retryTimes, _HttpAgent_backoffStrategy, _HttpAgent_waterMark, _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_requestAndRetryQuery, _HttpAgent_requestAndRetry, _HttpAgent_verifyQueryResponse;\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { hashOfMap, requestIdOf } from '../../request_id';\nimport { bufFromBufLike, concat, fromHex } from '../../utils/buffer';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport { makeNonce, SubmitRequestType } from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { request } from '../../canisterStatus';\nimport { CertificateVerificationError, LookupStatus, lookup_path } from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\nimport { decodeTime } from '../../utils/leb';\nimport { ObservableLog } from '../../observable';\nimport { ExponentialBackoff } from '../../polling/backoff';\nexport * from './transforms';\nexport { makeNonce } from './types';\nexport var RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n  RequestStatusResponseStatus[\"Received\"] = \"received\";\n  RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n  RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n  RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n  RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n  RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' + 'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' + '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' + 'b01291091c5f87b98883463f98091a0baaae';\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nclass HttpDefaultFetchError extends AgentError {\n  constructor(message) {\n    super(message);\n    this.message = message;\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(message) {\n    super(message);\n    this.message = message;\n  }\n}\nfunction getDefaultFetch() {\n  let defaultFetch;\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');\n}\nfunction determineHost(configuredHost) {\n  let host;\n  if (configuredHost !== undefined) {\n    if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n      host = new URL(window.location.protocol + '//' + configuredHost);\n    } else {\n      host = new URL(configuredHost);\n    }\n  } else {\n    // Mainnet, local, and remote environments will have the api route available\n    const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n    const remoteHosts = ['.github.dev', '.gitpod.io'];\n    const location = typeof window !== 'undefined' ? window.location : undefined;\n    const hostname = location === null || location === void 0 ? void 0 : location.hostname;\n    let knownHost;\n    if (hostname && typeof hostname === 'string') {\n      if (remoteHosts.some(host => hostname.endsWith(host))) {\n        knownHost = hostname;\n      } else {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n    }\n    if (location && knownHost) {\n      // If the user is on a boundary-node provided host, we can use the same host for the agent\n      host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n    } else {\n      host = new URL('https://icp-api.io');\n    }\n  }\n  return host.toString();\n}\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent {\n  /**\n   * @param options - Options for the HttpAgent\n   * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n   */\n  constructor(options = {}) {\n    var _a;\n    _HttpAgent_instances.add(this);\n    this.rootKey = fromHex(IC_ROOT_KEY);\n    _HttpAgent_identity.set(this, void 0);\n    _HttpAgent_fetch.set(this, void 0);\n    _HttpAgent_fetchOptions.set(this, void 0);\n    _HttpAgent_callOptions.set(this, void 0);\n    _HttpAgent_timeDiffMsecs.set(this, 0);\n    _HttpAgent_credentials.set(this, void 0);\n    _HttpAgent_rootKeyFetched.set(this, false);\n    _HttpAgent_retryTimes.set(this, void 0); // Retry requests N times before erroring by default\n    _HttpAgent_backoffStrategy.set(this, void 0);\n    // Public signature to help with type checking.\n    this._isAgent = true;\n    this.config = {};\n    // The UTC time in milliseconds when the latest request was made\n    _HttpAgent_waterMark.set(this, 0);\n    this.log = new ObservableLog();\n    _HttpAgent_queryPipeline.set(this, []);\n    _HttpAgent_updatePipeline.set(this, []);\n    _HttpAgent_subnetKeys.set(this, new ExpirableMap({\n      expirationTime: 5 * 60 * 1000 // 5 minutes\n    }));\n    _HttpAgent_verifyQuerySignatures.set(this, true);\n    /**\n     * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n     * @param queryResponse - The response from the query\n     * @param subnetStatus - The subnet status, including all node keys\n     * @returns ApiQueryResponse\n     */\n    _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {\n      if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\") === false) {\n        // This should not be called if the user has disabled verification\n        return queryResponse;\n      }\n      if (!subnetStatus) {\n        throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n      }\n      const {\n        status,\n        signatures = [],\n        requestId\n      } = queryResponse;\n      const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n      for (const sig of signatures) {\n        const {\n          timestamp,\n          identity\n        } = sig;\n        const nodeId = Principal.fromUint8Array(identity).toText();\n        let hash;\n        // Hash is constructed differently depending on the status\n        if (status === 'replied') {\n          const {\n            reply\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reply: reply,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else if (status === 'rejected') {\n          const {\n            reject_code,\n            reject_message,\n            error_code\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reject_code: reject_code,\n            reject_message: reject_message,\n            error_code: error_code,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else {\n          throw new Error(`Unknown status: ${status}`);\n        }\n        const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n        // FIX: check for match without verifying N times\n        const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);\n        if (!pubKey) {\n          throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n        }\n        const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n        const valid = ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));\n        if (valid) return queryResponse;\n        throw new CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);\n      }\n      return queryResponse;\n    });\n    this.config = options;\n    __classPrivateFieldSet(this, _HttpAgent_fetch, options.fetch || getDefaultFetch() || fetch.bind(global), \"f\");\n    __classPrivateFieldSet(this, _HttpAgent_fetchOptions, options.fetchOptions, \"f\");\n    __classPrivateFieldSet(this, _HttpAgent_callOptions, options.callOptions, \"f\");\n    const host = determineHost(options.host);\n    this.host = new URL(host);\n    if (options.verifyQuerySignatures !== undefined) {\n      __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, \"f\");\n    }\n    // Default is 3\n    __classPrivateFieldSet(this, _HttpAgent_retryTimes, (_a = options.retryTimes) !== null && _a !== void 0 ? _a : 3, \"f\");\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () => new ExponentialBackoff({\n      maxIterations: __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")\n    });\n    __classPrivateFieldSet(this, _HttpAgent_backoffStrategy, options.backoffStrategy || defaultBackoffFactory, \"f\");\n    // Rewrite to avoid redirects\n    if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this.host.hostname = IC0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this.host.hostname = ICP0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this.host.hostname = ICP_API_DOMAIN;\n    }\n    if (options.credentials) {\n      const {\n        name,\n        password\n      } = options.credentials;\n      __classPrivateFieldSet(this, _HttpAgent_credentials, `${name}${password ? ':' + password : ''}`, \"f\");\n    }\n    __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(options.identity || new AnonymousIdentity()), \"f\");\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n  get waterMark() {\n    return __classPrivateFieldGet(this, _HttpAgent_waterMark, \"f\");\n  }\n  static createSync(options = {}) {\n    return new this(Object.assign({}, options));\n  }\n  static async create(options = {\n    shouldFetchRootKey: false\n  }) {\n    const agent = HttpAgent.createSync(options);\n    const initPromises = [agent.syncTime()];\n    if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {\n      initPromises.push(agent.fetchRootKey());\n    }\n    await Promise.all(initPromises);\n    return agent;\n  }\n  static async from(agent) {\n    var _a;\n    try {\n      if ('config' in agent) {\n        return await HttpAgent.create(agent.config);\n      }\n      return await HttpAgent.create({\n        fetch: agent._fetch,\n        fetchOptions: agent._fetchOptions,\n        callOptions: agent._callOptions,\n        host: agent._host.toString(),\n        identity: (_a = agent._identity) !== null && _a !== void 0 ? _a : undefined\n      });\n    } catch (error) {\n      throw new AgentError('Failed to create agent from provided agent');\n    }\n  }\n  isLocal() {\n    const hostname = this.host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n  addTransform(type, fn, priority = fn.priority || 0) {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n      __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").length, 0, Object.assign(fn, {\n        priority\n      }));\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n      __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").length, 0, Object.assign(fn, {\n        priority\n      }));\n    }\n  }\n  async getPrincipal() {\n    if (!__classPrivateFieldGet(this, _HttpAgent_identity, \"f\")) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    return (await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\")).getPrincipal();\n  }\n  async call(canisterId, options, identity) {\n    const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n    if (!id) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;\n    const sender = id.getPrincipal() || Principal.anonymous();\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\")) > 1000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\"));\n    }\n    const submit = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest = await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n          Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n        } : {})\n      },\n      endpoint: \"call\" /* Endpoint.Call */,\n      body: submit\n    });\n    const nonce = transformedRequest.body.nonce ? toNonce(transformedRequest.body.nonce) : undefined;\n    submit.nonce = nonce;\n    function toNonce(buf) {\n      return new Uint8Array(buf);\n    }\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n    // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    const request = __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n      request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), {\n        body\n      })),\n      backoff,\n      tries: 0\n    });\n    const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n    const responseBuffer = await response.arrayBuffer();\n    const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null;\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        body: responseBody,\n        headers: httpHeadersTransform(response.headers)\n      },\n      requestDetails: submit\n    };\n  }\n  async query(canisterId, fields, identity) {\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    const ecid = fields.effectiveCanisterId ? Principal.from(fields.effectiveCanisterId) : Principal.from(canisterId);\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n      if (!id) {\n        throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n      }\n      const canister = Principal.from(canisterId);\n      const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n      const request = {\n        request_type: \"query\" /* ReadRequestType.Query */,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      };\n      const requestId = await requestIdOf(request);\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest = await this._transform({\n        request: {\n          method: 'POST',\n          headers: Object.assign({\n            'Content-Type': 'application/cbor'\n          }, __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n            Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n          } : {})\n        },\n        endpoint: \"read\" /* Endpoint.Query */,\n        body: request\n      });\n      // Apply transform for identity.\n      transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));\n      const body = cbor.encode(transformedRequest.body);\n      const args = {\n        canister: canister.toText(),\n        ecid,\n        transformedRequest,\n        body,\n        requestId,\n        backoff,\n        tries: 0\n      };\n      return {\n        requestDetails: request,\n        query: await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, args)\n      };\n    };\n    const getSubnetStatus = async () => {\n      if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n        return undefined;\n      }\n      const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n    };\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n    const {\n      requestDetails,\n      query\n    } = queryResult;\n    const queryWithDetails = Object.assign(Object.assign({}, query), {\n      requestDetails\n    });\n    this.log.print('Query response:', queryWithDetails);\n    // Skip verification if the user has disabled it\n    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n      return queryWithDetails;\n    }\n    try {\n      return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, subnetStatus);\n    } catch (_) {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").delete(canisterId.toString());\n      await this.fetchSubnetKeys(ecid.toString());\n      const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n      }\n      return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, updatedSubnetStatus);\n    }\n  }\n  async createReadStateRequest(fields, identity) {\n    const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n    if (!id) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n          Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n        } : {})\n      },\n      endpoint: \"read_state\" /* Endpoint.ReadState */,\n      body: {\n        request_type: \"read_state\" /* ReadRequestType.ReadState */,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      }\n    });\n    // Apply transform for identity.\n    return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);\n  }\n  async readState(canisterId, fields, identity,\n  // eslint-disable-next-line\n  request) {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n    const transformedRequest = request !== null && request !== void 0 ? request : await this.createReadStateRequest(fields, identity);\n    const body = cbor.encode(transformedRequest.body);\n    this.log.print(`fetching \"/api/v2/canister/${canister}/read_state\" with request:`, transformedRequest);\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n      request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), {\n        body\n      })),\n      backoff,\n      tries: 0\n    });\n    if (!response.ok) {\n      throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n    }\n    const decodedResponse = cbor.decode(await response.arrayBuffer());\n    this.log.print('Read state response:', decodedResponse);\n    const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n    if (parsedTime > 0) {\n      this.log.print('Read state response time:', parsedTime);\n      __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, \"f\");\n    }\n    return decodedResponse;\n  }\n  async parseTimeFromResponse(response) {\n    let tree;\n    if (response.certificate) {\n      const decoded = cbor.decode(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw new Error('Could not decode time from response');\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupStatus.Found) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      const date = decodeTime(bufFromBufLike(timeLookup.value));\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  async syncTime(canisterId) {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time']\n      });\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        __classPrivateFieldSet(this, _HttpAgent_timeDiffMsecs, Number(replicaTime) - Number(callTime), \"f\");\n      }\n    } catch (error) {\n      this.log.error('Caught exception while attempting to sync time', error);\n    }\n  }\n  async status() {\n    const headers = __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n      Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n    } : {};\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n      backoff,\n      request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/status`, this.host), Object.assign({\n        headers\n      }, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\"))),\n      tries: 0\n    });\n    return cbor.decode(await response.arrayBuffer());\n  }\n  async fetchRootKey() {\n    if (!__classPrivateFieldGet(this, _HttpAgent_rootKeyFetched, \"f\")) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = (await this.status()).root_key;\n      __classPrivateFieldSet(this, _HttpAgent_rootKeyFetched, true, \"f\");\n    }\n    return this.rootKey;\n  }\n  invalidateIdentity() {\n    __classPrivateFieldSet(this, _HttpAgent_identity, null, \"f\");\n  }\n  replaceIdentity(identity) {\n    __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(identity), \"f\");\n  }\n  async fetchSubnetKeys(canisterId) {\n    const effectiveCanisterId = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this\n    });\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").set(effectiveCanisterId.toText(), subnetResponse);\n      return subnetResponse;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n  _transform(request) {\n    let p = Promise.resolve(request);\n    if (request.endpoint === \"call\" /* Endpoint.Call */) {\n      for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\")) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\")) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n    return p;\n  }\n}\n_HttpAgent_identity = new WeakMap(), _HttpAgent_fetch = new WeakMap(), _HttpAgent_fetchOptions = new WeakMap(), _HttpAgent_callOptions = new WeakMap(), _HttpAgent_timeDiffMsecs = new WeakMap(), _HttpAgent_credentials = new WeakMap(), _HttpAgent_rootKeyFetched = new WeakMap(), _HttpAgent_retryTimes = new WeakMap(), _HttpAgent_backoffStrategy = new WeakMap(), _HttpAgent_waterMark = new WeakMap(), _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap(), _HttpAgent_instances = new WeakSet(), _HttpAgent_requestAndRetryQuery = async function _HttpAgent_requestAndRetryQuery(args) {\n  var _a, _b;\n  const {\n    ecid,\n    transformedRequest,\n    body,\n    requestId,\n    backoff,\n    tries\n  } = args;\n  const delay = tries === 0 ? 0 : backoff.next();\n  this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n    tries,\n    backoff,\n    delay\n  });\n  // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n  if (delay === null) {\n    throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n  }\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n  let response;\n  // Make the request and retry if it throws an error\n  try {\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`, transformedRequest);\n    const fetchResponse = await __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), {\n      body\n    }));\n    if (fetchResponse.status === 200) {\n      const queryResponse = cbor.decode(await fetchResponse.arrayBuffer());\n      response = Object.assign(Object.assign({}, queryResponse), {\n        httpDetails: {\n          ok: fetchResponse.ok,\n          status: fetchResponse.status,\n          statusText: fetchResponse.statusText,\n          headers: httpHeadersTransform(fetchResponse.headers)\n        },\n        requestId\n      });\n    } else {\n      throw new AgentHTTPResponseError(`Gateway returned an error:\\n` + `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` + `  Body: ${await fetchResponse.text()}\\n`, {\n        ok: fetchResponse.ok,\n        status: fetchResponse.status,\n        statusText: fetchResponse.statusText,\n        headers: httpHeadersTransform(fetchResponse.headers)\n      });\n    }\n  } catch (error) {\n    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n      this.log.warn(`Caught exception while attempting to make query:\\n` + `  ${error}\\n` + `  Retrying query.`);\n      return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), {\n        tries: tries + 1\n      }));\n    }\n    throw error;\n  }\n  const timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;\n  // Skip watermark verification if the user has set verifyQuerySignatures to false\n  if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n    return response;\n  }\n  if (!timestamp) {\n    throw new Error('Timestamp not found in query response. This suggests a malformed or malicious response.');\n  }\n  // Convert the timestamp to milliseconds\n  const timeStampInMs = Number(BigInt(timestamp) / BigInt(1000000));\n  this.log.print('watermark and timestamp', {\n    waterMark: this.waterMark,\n    timestamp: timeStampInMs\n  });\n  // If the timestamp is less than the watermark, retry the request up to the retry limit\n  if (Number(this.waterMark) > timeStampInMs) {\n    const error = new AgentError('Timestamp is below the watermark. Retrying query.');\n    this.log.error('Timestamp is below', error, {\n      timestamp,\n      waterMark: this.waterMark\n    });\n    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n      return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), {\n        tries: tries + 1\n      }));\n    }\n    {\n      throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n    }\n  }\n  return response;\n}, _HttpAgent_requestAndRetry = async function _HttpAgent_requestAndRetry(args) {\n  const {\n    request,\n    backoff,\n    tries\n  } = args;\n  const delay = tries === 0 ? 0 : backoff.next();\n  // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n  if (delay === null) {\n    throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n  }\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n  let response;\n  try {\n    response = await request();\n  } catch (error) {\n    if (__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\") > tries) {\n      this.log.warn(`Caught exception while attempting to make request:\\n` + `  ${error}\\n` + `  Retrying request.`);\n      // Delay the request by the configured backoff strategy\n      return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n        request,\n        backoff,\n        tries: tries + 1\n      });\n    }\n    throw error;\n  }\n  if (response.ok) {\n    return response;\n  }\n  const responseText = await response.clone().text();\n  const errorMessage = `Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${responseText}\\n`;\n  if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n    return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n      request,\n      backoff,\n      tries: tries + 1\n    });\n  }\n  throw new AgentHTTPResponseError(errorMessage, {\n    ok: response.ok,\n    status: response.status,\n    statusText: response.statusText,\n    headers: httpHeadersTransform(response.headers)\n  });\n};","map":{"version":3,"names":["Principal","AgentError","AnonymousIdentity","cbor","hashOfMap","requestIdOf","bufFromBufLike","concat","fromHex","Expiry","httpHeadersTransform","makeNonceTransform","makeNonce","SubmitRequestType","AgentHTTPResponseError","request","CertificateVerificationError","LookupStatus","lookup_path","ed25519","ExpirableMap","Ed25519PublicKey","decodeTime","ObservableLog","ExponentialBackoff","RequestStatusResponseStatus","DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS","IC_ROOT_KEY","MANAGEMENT_CANISTER_ID","IC0_DOMAIN","IC0_SUB_DOMAIN","ICP0_DOMAIN","ICP0_SUB_DOMAIN","ICP_API_DOMAIN","ICP_API_SUB_DOMAIN","HttpDefaultFetchError","constructor","message","IdentityInvalidError","getDefaultFetch","defaultFetch","window","fetch","bind","global","self","determineHost","configuredHost","host","undefined","match","URL","location","protocol","knownHosts","remoteHosts","hostname","knownHost","some","endsWith","find","port","toString","HttpAgent","options","rootKey","_HttpAgent_identity","set","_HttpAgent_fetch","_HttpAgent_fetchOptions","_HttpAgent_callOptions","_HttpAgent_timeDiffMsecs","_HttpAgent_credentials","_HttpAgent_rootKeyFetched","_HttpAgent_retryTimes","_HttpAgent_backoffStrategy","_isAgent","config","_HttpAgent_waterMark","log","_HttpAgent_queryPipeline","_HttpAgent_updatePipeline","_HttpAgent_subnetKeys","expirationTime","_HttpAgent_verifyQuerySignatures","_HttpAgent_verifyQueryResponse","queryResponse","subnetStatus","__classPrivateFieldGet","status","signatures","requestId","domainSeparator","TextEncoder","encode","sig","timestamp","identity","nodeId","fromUint8Array","toText","hash","reply","BigInt","request_id","reject_code","reject_message","error_code","Error","separatorWithHash","Uint8Array","pubKey","nodeKeys","get","rawKey","fromDer","valid","verify","signature","__classPrivateFieldSet","fetchOptions","callOptions","verifyQuerySignatures","_a","retryTimes","defaultBackoffFactory","maxIterations","backoffStrategy","credentials","name","password","Promise","resolve","addTransform","useQueryNonces","logToConsole","subscribe","level","console","error","warn","waterMark","createSync","Object","assign","create","shouldFetchRootKey","agent","initPromises","syncTime","push","fetchRootKey","all","from","_fetch","_fetchOptions","_callOptions","_host","_identity","isLocal","type","fn","priority","i","findIndex","x","splice","length","getPrincipal","call","canisterId","id","canister","ecid","effectiveCanisterId","sender","anonymous","ingress_expiry","Math","abs","submit","request_type","Call","canister_id","method_name","methodName","arg","transformedRequest","_transform","body","method","headers","Authorization","btoa","endpoint","nonce","toNonce","buf","transformRequest","print","backoff","_HttpAgent_instances","_HttpAgent_requestAndRetry","tries","response","responseBuffer","arrayBuffer","responseBody","byteLength","decode","ok","statusText","requestDetails","query","fields","makeQuery","args","_HttpAgent_requestAndRetryQuery","getSubnetStatus","fetchSubnetKeys","queryResult","queryWithDetails","_","delete","updatedSubnetStatus","createReadStateRequest","paths","readState","fromText","text","decodedResponse","parsedTime","parseTimeFromResponse","tree","certificate","decoded","timeLookup","Found","value","ArrayBuffer","isView","date","Number","CanisterStatus","callTime","Date","now","replicaTime","root_key","invalidateIdentity","replaceIdentity","subnetResponse","p","then","r","r2","delay","next","setTimeout","fetchResponse","httpDetails","_b","timeStampInMs","responseText","clone","errorMessage"],"sources":["/home/jeco/myprojects/icp/hopechain-frontend/node_modules/@dfinity/agent/src/agent/http/index.ts"],"sourcesContent":["import { JsonObject } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity, Identity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { RequestId, hashOfMap, requestIdOf } from '../../request_id';\nimport { bufFromBufLike, concat, fromHex } from '../../utils/buffer';\nimport {\n  Agent,\n  ApiQueryResponse,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from '../api';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport {\n  CallRequest,\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpAgentSubmitRequest,\n  makeNonce,\n  Nonce,\n  QueryRequest,\n  ReadRequestType,\n  SubmitRequestType,\n} from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { SubnetStatus, request } from '../../canisterStatus';\nimport {\n  CertificateVerificationError,\n  HashTree,\n  LookupStatus,\n  lookup_path,\n} from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\nimport { decodeTime } from '../../utils/leb';\nimport { ObservableLog } from '../../observable';\nimport { BackoffStrategy, BackoffStrategyFactory, ExponentialBackoff } from '../../polling/backoff';\nexport * from './transforms';\nexport { Nonce, makeNonce } from './types';\n\nexport enum RequestStatusResponseStatus {\n  Received = 'received',\n  Processing = 'processing',\n  Replied = 'replied',\n  Rejected = 'rejected',\n  Unknown = 'unknown',\n  Done = 'done',\n}\n\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY =\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n  'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n  '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n  'b01291091c5f87b98883463f98091a0baaae';\n\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\n\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\n\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\n\nclass HttpDefaultFetchError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\n\n// HttpAgent options that can be used at construction.\nexport interface HttpAgentOptions {\n  // A surrogate to the global fetch function. Useful for testing.\n  fetch?: typeof fetch;\n\n  // Additional options to pass along to fetch. Will not override fields that\n  // the agent already needs to set\n  // Should follow the RequestInit interface, but we intentially support non-standard fields\n  fetchOptions?: Record<string, unknown>;\n\n  // Additional options to pass along to fetch for the call API.\n  callOptions?: Record<string, unknown>;\n\n  // The host to use for the client. By default, uses the same host as\n  // the current page.\n  host?: string;\n\n  // The principal used to send messages. This cannot be empty at the request\n  // time (will throw).\n  identity?: Identity | Promise<Identity>;\n\n  credentials?: {\n    name: string;\n    password?: string;\n  };\n  /**\n   * Adds a unique {@link Nonce} with each query.\n   * Enabling will prevent queries from being answered with a cached response.\n   * @example\n   * const agent = new HttpAgent({ useQueryNonces: true });\n   * agent.addTransform(makeNonceTransform(makeNonce);\n   * @default false\n   */\n  useQueryNonces?: boolean;\n  /**\n   * Number of times to retry requests before throwing an error\n   * @default 3\n   */\n  retryTimes?: number;\n  /**\n   * The strategy to use for backoff when retrying requests\n   */\n  backoffStrategy?: BackoffStrategyFactory;\n  /**\n   * Whether the agent should verify signatures signed by node keys on query responses. Increases security, but adds overhead and must make a separate request to cache the node keys for the canister's subnet.\n   * @default true\n   */\n  verifyQuerySignatures?: boolean;\n  /**\n   * Whether to log to the console. Defaults to false.\n   */\n  logToConsole?: boolean;\n}\n\nfunction getDefaultFetch(): typeof fetch {\n  let defaultFetch;\n\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.',\n      );\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.',\n      );\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError(\n    'Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.',\n  );\n}\n\nfunction determineHost(configuredHost: string | undefined): string {\n  let host: URL;\n  if (configuredHost !== undefined) {\n    if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n      host = new URL(window.location.protocol + '//' + configuredHost);\n    } else {\n      host = new URL(configuredHost);\n    }\n  } else {\n    // Mainnet, local, and remote environments will have the api route available\n    const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n    const remoteHosts = ['.github.dev', '.gitpod.io'];\n    const location = typeof window !== 'undefined' ? window.location : undefined;\n    const hostname = location?.hostname;\n    let knownHost;\n    if (hostname && typeof hostname === 'string') {\n      if (remoteHosts.some(host => hostname.endsWith(host))) {\n        knownHost = hostname;\n      } else {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n    }\n\n    if (location && knownHost) {\n      // If the user is on a boundary-node provided host, we can use the same host for the agent\n      host = new URL(\n        `${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`,\n      );\n    } else {\n      host = new URL('https://icp-api.io');\n    }\n  }\n  return host.toString();\n}\n\ninterface V1HttpAgentInterface {\n  _identity: Promise<Identity> | null;\n  readonly _fetch: typeof fetch;\n  readonly _fetchOptions?: Record<string, unknown>;\n  readonly _callOptions?: Record<string, unknown>;\n\n  readonly _host: URL;\n  readonly _credentials: string | undefined;\n  readonly _retryTimes: number; // Retry requests N times before erroring by default\n  _isAgent: true;\n}\n\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent implements Agent {\n  public rootKey = fromHex(IC_ROOT_KEY);\n  #identity: Promise<Identity> | null;\n  readonly #fetch: typeof fetch;\n  readonly #fetchOptions?: Record<string, unknown>;\n  readonly #callOptions?: Record<string, unknown>;\n  #timeDiffMsecs = 0;\n  readonly host: URL;\n  readonly #credentials: string | undefined;\n  #rootKeyFetched = false;\n  readonly #retryTimes; // Retry requests N times before erroring by default\n  #backoffStrategy: BackoffStrategyFactory;\n\n  // Public signature to help with type checking.\n  public readonly _isAgent = true;\n  public config: HttpAgentOptions = {};\n\n  // The UTC time in milliseconds when the latest request was made\n  #waterMark = 0;\n\n  get waterMark(): number {\n    return this.#waterMark;\n  }\n\n  public log: ObservableLog = new ObservableLog();\n\n  #queryPipeline: HttpAgentRequestTransformFn[] = [];\n  #updatePipeline: HttpAgentRequestTransformFn[] = [];\n\n  #subnetKeys: ExpirableMap<string, SubnetStatus> = new ExpirableMap({\n    expirationTime: 5 * 60 * 1000, // 5 minutes\n  });\n  #verifyQuerySignatures = true;\n\n  /**\n   * @param options - Options for the HttpAgent\n   * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n   */\n  constructor(options: HttpAgentOptions = {}) {\n    this.config = options;\n    this.#fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n    this.#fetchOptions = options.fetchOptions;\n    this.#callOptions = options.callOptions;\n\n    const host = determineHost(options.host);\n    this.host = new URL(host);\n\n    if (options.verifyQuerySignatures !== undefined) {\n      this.#verifyQuerySignatures = options.verifyQuerySignatures;\n    }\n    // Default is 3\n    this.#retryTimes = options.retryTimes ?? 3;\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () =>\n      new ExponentialBackoff({\n        maxIterations: this.#retryTimes,\n      });\n    this.#backoffStrategy = options.backoffStrategy || defaultBackoffFactory;\n    // Rewrite to avoid redirects\n    if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this.host.hostname = IC0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this.host.hostname = ICP0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this.host.hostname = ICP_API_DOMAIN;\n    }\n\n    if (options.credentials) {\n      const { name, password } = options.credentials;\n      this.#credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this.#identity = Promise.resolve(options.identity || new AnonymousIdentity());\n\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n\n  public static createSync(options: HttpAgentOptions = {}): HttpAgent {\n    return new this({ ...options });\n  }\n\n  public static async create(\n    options: HttpAgentOptions & { shouldFetchRootKey?: boolean } = {\n      shouldFetchRootKey: false,\n    },\n  ): Promise<HttpAgent> {\n    const agent = HttpAgent.createSync(options);\n    const initPromises: Promise<ArrayBuffer | void>[] = [agent.syncTime()];\n    if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {\n      initPromises.push(agent.fetchRootKey());\n    }\n    await Promise.all(initPromises);\n    return agent;\n  }\n\n  public static async from(\n    agent: Pick<HttpAgent, 'config'> | V1HttpAgentInterface,\n  ): Promise<HttpAgent> {\n    try {\n      if ('config' in agent) {\n        return await HttpAgent.create(agent.config);\n      }\n      return await HttpAgent.create({\n        fetch: agent._fetch,\n        fetchOptions: agent._fetchOptions,\n        callOptions: agent._callOptions,\n        host: agent._host.toString(),\n        identity: agent._identity ?? undefined,\n      });\n    } catch (error) {\n      throw new AgentError('Failed to create agent from provided agent');\n    }\n  }\n\n  public isLocal(): boolean {\n    const hostname = this.host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n\n  public addTransform(\n    type: 'update' | 'query',\n    fn: HttpAgentRequestTransformFn,\n    priority = fn.priority || 0,\n  ): void {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#updatePipeline.splice(\n        i >= 0 ? i : this.#updatePipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#queryPipeline.splice(\n        i >= 0 ? i : this.#queryPipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    if (!this.#identity) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    return (await this.#identity).getPrincipal();\n  }\n\n  public async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: ArrayBuffer;\n      effectiveCanisterId?: Principal | string;\n    },\n    identity?: Identity | Promise<Identity>,\n  ): Promise<SubmitResponse> {\n    const id = await (identity !== undefined ? await identity : await this.#identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId\n      ? Principal.from(options.effectiveCanisterId)\n      : canister;\n\n    const sender: Principal = id.getPrincipal() || Principal.anonymous();\n\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(this.#timeDiffMsecs) > 1_000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this.#timeDiffMsecs);\n    }\n\n    const submit: CallRequest = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest: any = (await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.Call,\n      body: submit,\n    })) as HttpAgentSubmitRequest;\n\n    const nonce: Nonce | undefined = transformedRequest.body.nonce\n      ? toNonce(transformedRequest.body.nonce)\n      : undefined;\n\n    submit.nonce = nonce;\n\n    function toNonce(buf: ArrayBuffer): Nonce {\n      return new Uint8Array(buf) as Nonce;\n    }\n\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n\n    const body = cbor.encode(transformedRequest.body);\n\n    this.log.print(\n      `fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`,\n      transformedRequest,\n    );\n\n    // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n    const backoff = this.#backoffStrategy();\n    const request = this.#requestAndRetry({\n      request: () =>\n        this.#fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body,\n        }),\n      backoff,\n      tries: 0,\n    });\n\n    const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n\n    const responseBuffer = await response.arrayBuffer();\n    const responseBody = (\n      response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null\n    ) as SubmitResponse['response']['body'];\n\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        body: responseBody,\n        headers: httpHeadersTransform(response.headers),\n      },\n      requestDetails: submit,\n    };\n  }\n\n  async #requestAndRetryQuery(args: {\n    ecid: Principal;\n    transformedRequest: HttpAgentRequest;\n    body: ArrayBuffer;\n    requestId: RequestId;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<ApiQueryResponse> {\n    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n      tries,\n      backoff,\n      delay,\n    });\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw new AgentError(\n        `Timestamp failed to pass the watermark after retrying the configured ${\n          this.#retryTimes\n        } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response: ApiQueryResponse;\n    // Make the request and retry if it throws an error\n    try {\n      this.log.print(\n        `fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`,\n        transformedRequest,\n      );\n      const fetchResponse = await this.#fetch(\n        '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host),\n        {\n          ...this.#fetchOptions,\n          ...transformedRequest.request,\n          body,\n        },\n      );\n      if (fetchResponse.status === 200) {\n        const queryResponse: QueryResponse = cbor.decode(await fetchResponse.arrayBuffer());\n        response = {\n          ...queryResponse,\n          httpDetails: {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n          requestId,\n        };\n      } else {\n        throw new AgentHTTPResponseError(\n          `Gateway returned an error:\\n` +\n            `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` +\n            `  Body: ${await fetchResponse.text()}\\n`,\n          {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n        );\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(\n          `Caught exception while attempting to make query:\\n` +\n            `  ${error}\\n` +\n            `  Retrying query.`,\n        );\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      throw error;\n    }\n\n    const timestamp = response.signatures?.[0]?.timestamp;\n\n    // Skip watermark verification if the user has set verifyQuerySignatures to false\n    if (!this.#verifyQuerySignatures) {\n      return response;\n    }\n\n    if (!timestamp) {\n      throw new Error(\n        'Timestamp not found in query response. This suggests a malformed or malicious response.',\n      );\n    }\n\n    // Convert the timestamp to milliseconds\n    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1_000_000));\n\n    this.log.print('watermark and timestamp', {\n      waterMark: this.waterMark,\n      timestamp: timeStampInMs,\n    });\n\n    // If the timestamp is less than the watermark, retry the request up to the retry limit\n    if (Number(this.waterMark) > timeStampInMs) {\n      const error = new AgentError('Timestamp is below the watermark. Retrying query.');\n      this.log.error('Timestamp is below', error, {\n        timestamp,\n        waterMark: this.waterMark,\n      });\n      if (tries < this.#retryTimes) {\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      {\n        throw new AgentError(\n          `Timestamp failed to pass the watermark after retrying the configured ${\n            this.#retryTimes\n          } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n        );\n      }\n    }\n\n    return response;\n  }\n\n  async #requestAndRetry(args: {\n    request: () => Promise<Response>;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<Response> {\n    const { request, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw new AgentError(\n        `Timestamp failed to pass the watermark after retrying the configured ${\n          this.#retryTimes\n        } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n\n    let response: Response;\n    try {\n      response = await request();\n    } catch (error) {\n      if (this.#retryTimes > tries) {\n        this.log.warn(\n          `Caught exception while attempting to make request:\\n` +\n            `  ${error}\\n` +\n            `  Retrying request.`,\n        );\n        // Delay the request by the configured backoff strategy\n        return await this.#requestAndRetry({ request, backoff, tries: tries + 1 });\n      }\n      throw error;\n    }\n    if (response.ok) {\n      return response;\n    }\n\n    const responseText = await response.clone().text();\n    const errorMessage =\n      `Server returned an error:\\n` +\n      `  Code: ${response.status} (${response.statusText})\\n` +\n      `  Body: ${responseText}\\n`;\n\n    if (tries < this.#retryTimes) {\n      return await this.#requestAndRetry({ request, backoff, tries: tries + 1 });\n    }\n    throw new AgentHTTPResponseError(errorMessage, {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      headers: httpHeadersTransform(response.headers),\n    });\n  }\n\n  public async query(\n    canisterId: Principal | string,\n    fields: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<ApiQueryResponse> {\n    const backoff = this.#backoffStrategy();\n    const ecid = fields.effectiveCanisterId\n      ? Principal.from(fields.effectiveCanisterId)\n      : Principal.from(canisterId);\n\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await this.#identity);\n      if (!id) {\n        throw new IdentityInvalidError(\n          \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n        );\n      }\n\n      const canister = Principal.from(canisterId);\n      const sender = id?.getPrincipal() || Principal.anonymous();\n\n      const request: QueryRequest = {\n        request_type: ReadRequestType.Query,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      };\n\n      const requestId = await requestIdOf(request);\n\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest: HttpAgentRequest = await this._transform({\n        request: {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/cbor',\n            ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n          },\n        },\n        endpoint: Endpoint.Query,\n        body: request,\n      });\n\n      // Apply transform for identity.\n      transformedRequest = (await id?.transformRequest(transformedRequest)) as HttpAgentRequest;\n\n      const body = cbor.encode(transformedRequest.body);\n\n      const args = {\n        canister: canister.toText(),\n        ecid,\n        transformedRequest,\n        body,\n        requestId,\n        backoff,\n        tries: 0,\n      };\n\n      return {\n        requestDetails: request,\n        query: await this.#requestAndRetryQuery(args),\n      };\n    };\n\n    const getSubnetStatus = async (): Promise<SubnetStatus | void> => {\n      if (!this.#verifyQuerySignatures) {\n        return undefined;\n      }\n      const subnetStatus = this.#subnetKeys.get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return this.#subnetKeys.get(ecid.toString());\n    };\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n    const { requestDetails, query } = queryResult;\n\n    const queryWithDetails = {\n      ...query,\n      requestDetails,\n    };\n\n    this.log.print('Query response:', queryWithDetails);\n    // Skip verification if the user has disabled it\n    if (!this.#verifyQuerySignatures) {\n      return queryWithDetails;\n    }\n\n    try {\n      return this.#verifyQueryResponse(queryWithDetails, subnetStatus);\n    } catch (_) {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      this.#subnetKeys.delete(canisterId.toString());\n      await this.fetchSubnetKeys(ecid.toString());\n\n      const updatedSubnetStatus = this.#subnetKeys.get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      return this.#verifyQueryResponse(queryWithDetails, updatedSubnetStatus);\n    }\n  }\n\n  /**\n   * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n   * @param queryResponse - The response from the query\n   * @param subnetStatus - The subnet status, including all node keys\n   * @returns ApiQueryResponse\n   */\n  #verifyQueryResponse = (\n    queryResponse: ApiQueryResponse,\n    subnetStatus: SubnetStatus | void,\n  ): ApiQueryResponse => {\n    if (this.#verifyQuerySignatures === false) {\n      // This should not be called if the user has disabled verification\n      return queryResponse;\n    }\n    if (!subnetStatus) {\n      throw new CertificateVerificationError(\n        'Invalid signature from replica signed query: no matching node key found.',\n      );\n    }\n    const { status, signatures = [], requestId } = queryResponse;\n\n    const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n    for (const sig of signatures) {\n      const { timestamp, identity } = sig;\n      const nodeId = Principal.fromUint8Array(identity).toText();\n      let hash: ArrayBuffer;\n\n      // Hash is constructed differently depending on the status\n      if (status === 'replied') {\n        const { reply } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reply: reply,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else if (status === 'rejected') {\n        const { reject_code, reject_message, error_code } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reject_code: reject_code,\n          reject_message: reject_message,\n          error_code: error_code,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else {\n        throw new Error(`Unknown status: ${status}`);\n      }\n\n      const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n\n      // FIX: check for match without verifying N times\n      const pubKey = subnetStatus?.nodeKeys.get(nodeId);\n      if (!pubKey) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n      const valid = ed25519.verify(\n        sig.signature,\n        new Uint8Array(separatorWithHash),\n        new Uint8Array(rawKey),\n      );\n      if (valid) return queryResponse;\n\n      throw new CertificateVerificationError(\n        `Invalid signature from replica ${nodeId} signed query.`,\n      );\n    }\n    return queryResponse;\n  };\n\n  public async createReadStateRequest(\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const id = await (identity !== undefined ? await identity : await this.#identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const sender = id?.getPrincipal() || Principal.anonymous();\n\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest: any = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      },\n    });\n\n    // Apply transform for identity.\n    return id?.transformRequest(transformedRequest);\n  }\n\n  public async readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line\n    request?: any,\n  ): Promise<ReadStateResponse> {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n\n    const transformedRequest = request ?? (await this.createReadStateRequest(fields, identity));\n    const body = cbor.encode(transformedRequest.body);\n\n    this.log.print(\n      `fetching \"/api/v2/canister/${canister}/read_state\" with request:`,\n      transformedRequest,\n    );\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const backoff = this.#backoffStrategy();\n\n    const response = await this.#requestAndRetry({\n      request: () =>\n        this.#fetch('' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), {\n          ...this.#fetchOptions,\n          ...transformedRequest.request,\n          body,\n        }),\n      backoff,\n      tries: 0,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Server returned an error:\\n` +\n          `  Code: ${response.status} (${response.statusText})\\n` +\n          `  Body: ${await response.text()}\\n`,\n      );\n    }\n    const decodedResponse: ReadStateResponse = cbor.decode(await response.arrayBuffer());\n\n    this.log.print('Read state response:', decodedResponse);\n    const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n    if (parsedTime > 0) {\n      this.log.print('Read state response time:', parsedTime);\n      this.#waterMark = parsedTime;\n    }\n\n    return decodedResponse;\n  }\n\n  public async parseTimeFromResponse(response: ReadStateResponse): Promise<number> {\n    let tree: HashTree;\n    if (response.certificate) {\n      const decoded: { tree: HashTree } | undefined = cbor.decode(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw new Error('Could not decode time from response');\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupStatus.Found) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n\n      if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      const date = decodeTime(bufFromBufLike(timeLookup.value as ArrayBuffer));\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  public async syncTime(canisterId?: Principal): Promise<void> {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        this.log.print(\n          'Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai',\n        );\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time'],\n      });\n\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        this.#timeDiffMsecs = Number(replicaTime as bigint) - Number(callTime);\n      }\n    } catch (error) {\n      this.log.error('Caught exception while attempting to sync time', error as AgentError);\n    }\n  }\n\n  public async status(): Promise<JsonObject> {\n    const headers: Record<string, string> = this.#credentials\n      ? {\n          Authorization: 'Basic ' + btoa(this.#credentials),\n        }\n      : {};\n\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = this.#backoffStrategy();\n    const response = await this.#requestAndRetry({\n      backoff,\n      request: () =>\n        this.#fetch('' + new URL(`/api/v2/status`, this.host), { headers, ...this.#fetchOptions }),\n      tries: 0,\n    });\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    if (!this.#rootKeyFetched) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = ((await this.status()) as JsonObject & { root_key: ArrayBuffer }).root_key;\n      this.#rootKeyFetched = true;\n    }\n    return this.rootKey;\n  }\n\n  public invalidateIdentity(): void {\n    this.#identity = null;\n  }\n\n  public replaceIdentity(identity: Identity): void {\n    this.#identity = Promise.resolve(identity);\n  }\n\n  public async fetchSubnetKeys(canisterId: Principal | string) {\n    const effectiveCanisterId: Principal = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this,\n    });\n\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse as SubnetStatus);\n      return subnetResponse as SubnetStatus;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n\n  protected _transform(request: HttpAgentRequest): Promise<HttpAgentRequest> {\n    let p = Promise.resolve(request);\n    if (request.endpoint === Endpoint.Call) {\n      for (const fn of this.#updatePipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of this.#queryPipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n\n    return p;\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}